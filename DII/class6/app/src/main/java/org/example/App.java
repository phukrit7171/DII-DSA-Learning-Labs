/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import org.example.algorithms.*;
import org.example.utils.ChartUtils;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class App {
    private static final int NUM_TRIALS = 20;  // Number of trials for each n
    private static final int[] TEST_SIZES = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 50, 100};  // Different input sizes to test

    public static void main(String[] args) {
        System.out.println("Starting performance testing...\n");

        // Initialize algorithms to test
        Map<String, PerformanceTestable> algorithmsToTest = new LinkedHashMap<>();
        algorithmsToTest.put("Question1", new Question1Algorithm());
        algorithmsToTest.put("Question2", new Question2Algorithm());
        algorithmsToTest.put("Question3", new Question3Algorithm());

        // Test each algorithm
        for (Map.Entry<String, PerformanceTestable> entry : algorithmsToTest.entrySet()) {
            String algorithmName = entry.getKey();
            PerformanceTestable algorithm = entry.getValue();

            System.out.println("\nTesting Algorithm: " + algorithmName);

            // Store results for plotting
            List<Double> nValues = new ArrayList<>();
            List<Double> timeValues = new ArrayList<>();

            // Test with different input sizes
            for (int n : TEST_SIZES) {
                // Run multiple trials and average the results
                long totalTime = 0;
                for (int trial = 0; trial < NUM_TRIALS; trial++) {
                    int[] inputArray = generateRandomArray(n);
                    int[] outputArray = new int[n];

                    // Time the execution
                    long startTime = System.nanoTime();
                    algorithm.execute(inputArray, outputArray);
                    long endTime = System.nanoTime();

                    totalTime += (endTime - startTime);
                }

                // Calculate average time
                double avgTime = (double) totalTime / NUM_TRIALS;
                
                // Store results
                nValues.add((double) n);
                timeValues.add(avgTime);

                // Print results
                System.out.printf("n = %4d, Avg. Time = %.2f ns%n", n, avgTime);
            }

            // Create performance chart
            Map<String, List<Double>> measuredSeries = new HashMap<>();
            measuredSeries.put(algorithmName, timeValues);

            // Generate theoretical complexities for comparison
            Map<String, List<Double>> theoreticalSeries = generateTheoreticalSeries(nValues);

            ChartUtils.createAndSavePerformanceChart(
                algorithmName + "_Performance",
                nValues,
                measuredSeries,
                theoreticalSeries
            );
        }

        System.out.println("\nAll tests complete. Graphs saved to src/main/resources/graphs/");
    }

    private static int[] generateRandomArray(int size) {
        int[] array = new int[size];
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(100); // Random numbers between 0 and 99
        }
        return array;
    }

    private static Map<String, List<Double>> generateTheoreticalSeries(List<Double> nValues) {
        Map<String, List<Double>> series = new HashMap<>();
        
        // Generate different complexity curves
        List<Double> linear = new ArrayList<>();
        List<Double> quadratic = new ArrayList<>();
        List<Double> cubic = new ArrayList<>();
        
        // Scale factors to make theoretical curves visible on same chart
        double linearScale = 1000;
        double quadraticScale = 100;
        double cubicScale = 10;
        
        for (double n : nValues) {
            linear.add(n * linearScale);
            quadratic.add(n * n * quadraticScale);
            cubic.add(n * n * n * cubicScale);
        }
        
        series.put("O(n)", linear);
        series.put("O(n²)", quadratic);
        series.put("O(n³)", cubic);
        
        return series;
    }
}
